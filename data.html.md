# data


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

We will build a simple ingestion pipeline to ingest pdf documents into
litesearch database for searching.

Extensions to pymupdf Document and Page classes to extract texts, images
and links

    /opt/hostedtoolcache/Python/3.10.19/x64/lib/python3.10/site-packages/usearch/__init__.py:125: UserWarning: Will download `usearch_sqlite` binary from GitHub.
      warnings.warn("Will download `usearch_sqlite` binary from GitHub.", UserWarning)

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#L39"
target="_blank" style="float:right; font-size:smaller">source</a>

### Document.ext_imgs

>  Document.ext_imgs (st=0, end=-1)

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#LNone"
target="_blank" style="float:right; font-size:smaller">source</a>

### Document.ext_im

>  Document.ext_im (it=None)

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#LNone"
target="_blank" style="float:right; font-size:smaller">source</a>

### Document.get_links

>  Document.get_links (st=0, end=-1)

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#LNone"
target="_blank" style="float:right; font-size:smaller">source</a>

### Document.get_texts

>  Document.get_texts (st=0, end=-1, **kw)

Code extraction utilities

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#L44"
target="_blank" style="float:right; font-size:smaller">source</a>

### pyparse

>  pyparse (p:pathlib.Path=None, code:str=None, imports=False)

*Parse a code string or python file and return code chunks as list of
dicts with content and metadata.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>Path</td>
<td>None</td>
<td>path to a python file</td>
</tr>
<tr>
<td>code</td>
<td>str</td>
<td>None</td>
<td>code string to parse</td>
</tr>
<tr>
<td>imports</td>
<td>bool</td>
<td>False</td>
<td>include import statements as code chunks</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>L</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

You can use
[`pyparse`](https://Karthik777.github.io/litesearch/data.html#pyparse)
to extract code chunks from a python file or code string.

``` python
txt = """
from fastcore.all import *
a=1
class SomeClass:
    def __init__(self,x): store_attr()
    def method(self): return self.x + a
 """
pyparse(code=txt)
```

    (#2) [{'content': 'a=1', 'metadata': {'path': None, 'uploaded_at': None, 'name': None, 'type': 'Assign', 'lineno': 3, 'end_lineno': 3}},{'content': 'class SomeClass:\n    def __init__(self,x): store_attr()\n    def method(self): return self.x + a', 'metadata': {'path': None, 'uploaded_at': None, 'name': 'SomeClass', 'type': 'ClassDef', 'lineno': 4, 'end_lineno': 6}}]

Setting imports to True will also include import statements as code
chunks.

``` python
pyparse(code=txt, imports=True)
```

    (#3) [{'content': 'from fastcore.all import *', 'metadata': {'path': None, 'uploaded_at': None, 'name': None, 'type': 'ImportFrom', 'lineno': 2, 'end_lineno': 2}},{'content': 'a=1', 'metadata': {'path': None, 'uploaded_at': None, 'name': None, 'type': 'Assign', 'lineno': 3, 'end_lineno': 3}},{'content': 'class SomeClass:\n    def __init__(self,x): store_attr()\n    def method(self): return self.x + a', 'metadata': {'path': None, 'uploaded_at': None, 'name': 'SomeClass', 'type': 'ClassDef', 'lineno': 4, 'end_lineno': 6}}]

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#L82"
target="_blank" style="float:right; font-size:smaller">source</a>

### pkg2chunks

>  pkg2chunks (pkg:str, imports:bool=False, **kw)

*Return code chunks from a package with extra metadata.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>pkg</td>
<td>str</td>
<td></td>
<td>package name</td>
</tr>
<tr>
<td>imports</td>
<td>bool</td>
<td>False</td>
<td>include import statements as code chunks</td>
</tr>
<tr>
<td>kw</td>
<td>VAR_KEYWORD</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>L</strong></td>
<td></td>
<td><strong>additional args to pass to pkg2files</strong></td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#L69"
target="_blank" style="float:right; font-size:smaller">source</a>

### pkg2files

>  pkg2files (pkg:str, file_glob:str='*.py', skip_file_glob:str='_*', skip_f
>                 ile_re='(^__init__\\.py$|^setup\\.py$|^conftest\\.py$|^test_.*
>                 \\.py$|^tests?\\.py$|^.*_test\\.py$)', skip_folder_re='(^tests
>                 ?$|^__pycache__$|^\\.eggs$|^\\.mypy_cache$|^\\.tox$|^examples?
>                 $|^docs?$|^build$|^dist$|^\\.git$|^\\.ipynb_checkpoints$)',
>                 recursive:bool=True, symlinks:bool=True, file_re:str=None,
>                 folder_re:str=None, func:callable=<function join>,
>                 ret_folders:bool=False, sort:bool=True)

*Return list of python files in a package excluding tests and setup
files.*

<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>pkg</td>
<td>str</td>
<td></td>
<td>package name</td>
</tr>
<tr>
<td>file_glob</td>
<td>str</td>
<td>*.py</td>
<td>file glob to match</td>
</tr>
<tr>
<td>skip_file_glob</td>
<td>str</td>
<td>_*</td>
<td>file glob to skip</td>
</tr>
<tr>
<td>skip_file_re</td>
<td>str</td>
<td>(^<strong>init</strong>.py<span
class="math inline">$\|\^setup\.py$</span>|^conftest.py<span
class="math inline">$\|\^test_.*\.py$</span>|^tests?.py<span
class="math inline">$\|\^.*_test\.py$</span>)</td>
<td>regex to skip files</td>
</tr>
<tr>
<td>skip_folder_re</td>
<td>str</td>
<td>(^tests?<span
class="math inline">$\|\^__pycache__$</span>|^.eggs<span
class="math inline">$\|\^\.mypy_cache$</span>|^.tox<span
class="math inline">∥^<em>e</em><em>x</em><em>a</em><em>m</em><em>p</em><em>l</em><em>e</em><em>s</em>?</span>|^docs?<span
class="math inline">∥^<em>b</em><em>u</em><em>i</em><em>l</em><em>d</em></span>|^dist<span
class="math inline">$\|\^\.git$</span>|^.ipynb_checkpoints$)</td>
<td>regex to skip folders</td>
</tr>
<tr>
<td>recursive</td>
<td>bool</td>
<td>True</td>
<td>search subfolders</td>
</tr>
<tr>
<td>symlinks</td>
<td>bool</td>
<td>True</td>
<td>follow symlinks?</td>
</tr>
<tr>
<td>file_re</td>
<td>str</td>
<td>None</td>
<td>Only include files matching regex</td>
</tr>
<tr>
<td>folder_re</td>
<td>str</td>
<td>None</td>
<td>Only enter folders matching regex</td>
</tr>
<tr>
<td>func</td>
<td>callable</td>
<td>join</td>
<td>function to apply to each matched file</td>
</tr>
<tr>
<td>ret_folders</td>
<td>bool</td>
<td>False</td>
<td>return folders, not just files</td>
</tr>
<tr>
<td>sort</td>
<td>bool</td>
<td>True</td>
<td>sort files by name within each folder</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>L</strong></td>
<td></td>
<td><strong>additional args to pass to globtastic</strong></td>
</tr>
</tbody>
</table>

[`pkg2chunks`](https://Karthik777.github.io/litesearch/data.html#pkg2chunks)
can be used to extract code chunks from an entire package installed in
your environment.

``` python
chunks=pkg2chunks('fastlite')
chunks.filter(lambda d: d['metadata']['type']=='FunctionDef')[0]
```

    {'content': 'def t(self:Database): return _TablesGetter(self)',
     'metadata': {'path': '/Users/71293/code/litesearch/.venv/lib/python3.13/site-packages/fastlite/core.py',
      'uploaded_at': 1752468812.9739048,
      'name': 't',
      'type': 'FunctionDef',
      'lineno': 44,
      'end_lineno': 44,
      'package': 'fastlite',
      'version': '0.2.1'}}

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#L92"
target="_blank" style="float:right; font-size:smaller">source</a>

### installed_packages

>  installed_packages (nms:list=None)

*Return list of installed packages. If nms is provided, return only
those packages.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>nms</td>
<td>list</td>
<td>None</td>
<td>list of package names</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td><strong>L</strong></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

Get list of installed packages in your environment using
[`installed_packages`](https://Karthik777.github.io/litesearch/data.html#installed_packages).
If you pass a list of package names, it only returns them if they exist
in your environment.

``` python
installed_packages(['fstlite']) # non existent package
installed_packages(['fastlite']) # existing package
installed_packages() # all installed packages that are not stdlib
```

    (#179) ['litesearch','shellingham','jiter','ipykernel','simsimd','threadpoolctl','coloredlogs','uri-template','humanfriendly','socksio','rfc3339-validator','pexpect','jupyterlab-quarto','fqdn','requests','babel','rich','traitlets','tokenizers','urllib3'...]

Query Preprocessing utilities

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#L123"
target="_blank" style="float:right; font-size:smaller">source</a>

### pre

>  pre (q:str, wc=True, wide=True, extract_kw=True)

*Preprocess the query for fts search.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>str</td>
<td></td>
<td>query to be passed for fts search</td>
</tr>
<tr>
<td>wc</td>
<td>bool</td>
<td>True</td>
<td>add wild card to each word</td>
</tr>
<tr>
<td>wide</td>
<td>bool</td>
<td>True</td>
<td>widen the query with OR operator</td>
</tr>
<tr>
<td>extract_kw</td>
<td>bool</td>
<td>True</td>
<td>extract keywords from the query</td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#L117"
target="_blank" style="float:right; font-size:smaller">source</a>

### kw

>  kw (q:str)

*Extract keywords from the query using YAKE library.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>str</td>
<td>query to be passed for fts search</td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#L112"
target="_blank" style="float:right; font-size:smaller">source</a>

### mk_wider

>  mk_wider (q:str)

*Widen the query by joining words with OR operator.*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>str</td>
<td>query to be passed for fts search</td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#L107"
target="_blank" style="float:right; font-size:smaller">source</a>

### add_wc

>  add_wc (q:str)

*Add wild card * to each word in the query.\*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>str</td>
<td>query to be passed for fts search</td>
</tr>
</tbody>
</table>

------------------------------------------------------------------------

<a
href="https://github.com/Karthik777/litesearch/blob/main/litesearch/data.py#L102"
target="_blank" style="float:right; font-size:smaller">source</a>

### clean

>  clean (q:str)

*Clean the query by removing * and returning None for empty queries.\*

<table>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>q</td>
<td>str</td>
<td>query to be passed for fts search</td>
</tr>
</tbody>
</table>

You can clean queries passed into fts search using
[`clean`](https://Karthik777.github.io/litesearch/data.html#clean), add
wild cards using
[`add_wc`](https://Karthik777.github.io/litesearch/data.html#add_wc),
widen the query using
[`mk_wider`](https://Karthik777.github.io/litesearch/data.html#mk_wider)
and extract keywords using
[`kw`](https://Karthik777.github.io/litesearch/data.html#kw). You can
combine all these using
[`pre`](https://Karthik777.github.io/litesearch/data.html#pre) function.

``` python
q = 'This is a sample query'
print('preprocessed q with defaults: `%s`' %pre(q))
print('keywords extracted: `%s`' %pre(q, wc=False, wide=False))
print('q with wild card: `%s`' %pre(q, extract_kw=False, wide=False, wc=True))
```

    preprocessed q with defaults: `query* OR sample*`
    keywords extracted: `query sample`
    q with wild card: `This* is* a* sample* query*`
